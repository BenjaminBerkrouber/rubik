# ALGO.md — Kociemba Two-Phase Algorithm

This document explains the solving algorithm implemented in our Rubik’s Cube solver.  
We use the **Two-Phase Algorithm** introduced by Herbert Kociemba, one of the most efficient and widely used approaches for generating short solutions in a reasonable amount of time.

Reference:  
➡️ https://kociemba.org/cube.htm

---

# 1. Overview of Kociemba’s Two-Phase Method

Kociemba’s algorithm splits the solving process into **two distinct phases**, each with its own constraints and sub-group of cube states.

The main idea:

- Instead of solving the cube in a single search space of size **43 quintillion states**,  
- we restrict the search to smaller, more structured subgroups,  
- dramatically reducing the number of possible states to explore.

This allows fast optimal or near-optimal solutions.

---

# 2. Cube Group Theory — The Concept Behind It

The Rubik’s Cube is a group generated by 6 basic face turns.  
Kociemba divides this group into:

### **Phase 1 Group (G₀ → G₁)**  
Goal: transform the cube into a restricted subset of states, called **G₁**, where:

- all edges have correct orientation  
- all corners have correct orientation  
- the UD (Up–Down) edges are in the UD slice  
- parity constraints are respected  

In other words, Phase 1 reduces the cube to a state that is “compatible” with Phase 2.

### **Phase 2 Group (G₁ → solved)**  
Once the cube is in G₁, moves are restricted to the **half-turn metric (HTM)** subgroup:

Allowed moves:

- half turns (U2, D2, F2, B2, L2, R2)  
- face turns on the U and D layers (U, U', D, D')  

These moves preserve the constraints achieved in G₁.  
Phase 2 then solves the cube completely.

---

# 3. The Search Strategy

The solver uses **Iterative Deepening A\*** (IDA\*) in both phases.

IDA\* explores the tree of moves with:

1. increasing depth limits  
2. a heuristic estimate of the remaining distance  
3. pruning tables to reject impossible or inefficient states

This combination keeps the search extremely fast.

---

# 4. Pruning Tables (Key Component)

Pruning tables are the core of Kociemba's performance.

A **pruning table** is a precomputed array that stores:  
> The *minimum number of moves* required to reach the subgroup constraint (G₁ or the solved state), for every possible configuration of a certain coordinate.

They are used as admissible heuristics for IDA\*.

### 4.1 What They Store

For a given coordinate (e.g., edge orientation, corner twist, slice position):

- each entry corresponds to a specific state or partial state  
- the stored value is the minimal distance to reach the target subgroup

Example (conceptual):

- twist coordinate → minimal moves to orient all corners  
- flip coordinate → minimal moves to orient all edges  
- slice coordinate → minimal moves to bring UD edges into the UD slice  

These distances form **lower bounds** for search depth.

### 4.2 Why They Are Powerful

During IDA\* search:

- if `current depth + pruning value > max depth limit`  
→ the branch is **cut early**  
→ huge parts of the search tree are never explored

This eliminates millions of impossible states instantly.

---

# 5. IDA\* Loop with Heuristics

During each iteration of IDA\*, the solver:

1. evaluates the cube’s coordinates (twist, flip, slice, etc.)  
2. retrieves pruning distances  
3. checks if the state is worth exploring  
4. generates the next legal moves  
5. continues depth-first until a solution is found or the depth limit is reached

The process repeats with increased maximum depth.

---

# 6. Move Reduction Heuristics (Avoiding Redundant Sequences)

To further accelerate the solver, we integrate two additional heuristics that prevent exploring sequences of moves known to be redundant or inefficient.

These are **not part of Kociemba’s theory**, but they drastically improve real-world performance.

### 6.1 Axis Locking — Avoiding Same-Axis Moves

Two consecutive moves on the **same axis** usually do not create meaningful progress (e.g., U → U’, R → R, L → L2).  
They produce many equivalent states.

The heuristic prevents exploring:

- two moves on the same axis in a row  
- three adjacent face turns that form a commutator  
- unnecessary sequences like U U', R R2, F F2

This reduces branching factor and accelerates IDA\*.

### 6.2 Face Locking — Avoiding Same-Face Moves

Depending on the mode selected:

- one heuristic blocks moves on the **same face group** (U, U', U2 considered similar)  
- the other blocks moves on the **same axis group** (U/D, L/R, F/B considered similar)

These heuristics drastically reduce the move set without losing optimal solutions.

This is essential when the solver is configured for:

- **least number of moves**  
- **fastest execution time**  

Both options favor different pruning strategies.

---

# 7. Phase Transition (G₀ → G₁ → Solved)

### Phase 1:

- search for shortest path to reach the G₁ subgroup  
- use pruning tables for twist/flip/slice coordinates  
- result: a sequence of moves bringing cube into G₁

### Phase 2:

- continue with a restricted move set  
- use pruning tables suited to G₁ states  
- finalize the cube to solved state  

The final solution is:

solution = phase1_sequence + phase2_sequence
Solutions are typically **20–25 moves**, sometimes fewer.

---

# 8. Why Kociemba?

Advantages:

- **massive reduction in search space**  
- **much shorter solutions** than naive IDA\*  
- **fast enough for real-time solving**  
- **very efficient combination of group theory + heuristics**  
- widely used in professional solvers, robots, and competition scramblers

---

# 9. Reference

Kociemba’s official website:  
➡️ https://kociemba.org/cube.htm

Contains theory, tables, and mathematical background of the algorithm.