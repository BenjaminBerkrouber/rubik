#pragma once

#include "cube/CubeState.hpp"
#include "spin/SpinManager.hpp"
#include "parser/Parser.hpp"
#include "engine/IEngine.hpp"
#include "solver/ISolver.hpp"

#include <iostream>

/**
 * @class RubikController
 * @brief Central controller that coordinates the main components of the Rubik's Cube application.
 *
 * This class acts as the brain of the program, managing and orchestrating the core components:
 * - CubeState (state representation)
 * - Parser (parsing input moves)
 * - SpinManager (applying moves to the cube)
 * - ISolver (abstract interface for solving the cube)
 * - IEngine (abstract interface for rendering or printing the cube)
 *
 * The controller provides utility methods to parse input, apply shuffles, display the cube,
 * and invoke the solving algorithm.
 */
class RubikController {
    private:
        CubeState       _cubeState;     /**< Represents the current state of the Rubik's Cube */
        Parser          _parser;        /**< Parses input spin sequences */
        SpinManager     _spinManager;   /**< Applies spin moves to the cube */
        ISolver         *_solver = nullptr; /**< Pointer to the solver interface */
        IEngine         *_engine = nullptr; /**< Pointer to the engine interface (display handler) */

        /**
        * @brief Applies a random shuffle of the cube.
        *
        * @param count Number of random spins to apply
        * @return true if shuffle succeeded, false otherwise
        */
        ParseResult randomSuffle(int count);

    public:
        /**
        * @brief Constructs a RubikController and initializes all components.
        */
        RubikController(IEngine * engine);

        /**
        * @brief Default destructor.
        */
        ~RubikController();

        /**
        * @brief Parses and applies a string of moves or applies a random shuffle based on environment variable.
        *
        * If the environment variable "RUBIK_MODE" is set to "RANDOM", applies a random shuffle.
        * Otherwise, parses and applies the input moves.
        *
        * @param input A string representing the sequence of spins (ignored if random shuffle)
        * @return true if the operation succeeds, false otherwise
        */
        ParseResult parse(const std::string& input);

        /**
        * @brief Applies a shuffle to the cube (used for randomizing).
        */
        void applySuffle();

        /**
        * @brief Displays or prints the current state of the cube using the selected engine.
        */
        void print() const;

        /**
        * @brief Solves the cube using the selected solving algorithm.
        */
        bool solve(int algorithm = 0);

        /**
         * @brief Resets the RubikController to its initial state.
         *
         * This method reinitializes the cube state, clears any parsing results,
         * and safely deletes and recreates the solver and engine components.
         * After calling this function, the controller will be in a clean state,
         * ready for new operations.
         */
        void reset();

        /**
         * @brief Generates a random sequence of SpinLst instructions.
         * This method clears any previous results and generates a new set of random spins.
         * It is useful for creating new shuffle patterns for the cube.
         * @param count The number of random SpinLst instructions to generate.
         */
        void generateRandomSpinLst(int count);

        /**
         * @brief Retrieves the current shuffle moves applied to the cube.
         * This method returns the list of moves that were used to shuffle the cube.
         * It is useful for understanding the initial state before solving.
         * @return A vector containing the shuffle moves as SpinLst instructions.
         */
        std::vector<SpinLst> getShuffle() const;

        /**
         * @brief Retrieves the solution to the cube as a vector of SpinLst instructions.
         *
         * This method returns the solution generated by the Kociemba solver.
         * It is expected that the solver has been successfully executed before calling this method.
         *
         * @return A vector containing the moves to solve the cube.
         */
        std::vector<SpinLst> getSolution() const;

        /**
         * @brief Retrieves the inverse of a given sequence of SpinLst instructions.
         *
         * This method computes the inverse of the provided spins, which can be useful for undoing moves.
         * The inverse is calculated by reversing the order and inverting each individual spin.
         *
         * @param spins The vector of SpinLst instructions to invert.
         * @return A vector containing the inverted SpinLst instructions.
         */
        std::vector<SpinLst> getInverseSpins(const std::vector<SpinLst> &spins) const;

};